"""
Natural Language Interface - Refactored with Native Function Calling

Convert plain English to stock queries using Gemini's function calling API

ARCHITECTURE CHANGE:
- OLD: Prompt-based JSON generation (brittle, requires parsing)
- NEW: Native function calling (structured, type-safe, reliable)

Reference: FROM_SCRATCH_DOCS/LLM_INTEGRATION_COMPLETE_GUIDE.md
"""

import sys
from pathlib import Path
from typing import Dict, Any, Optional

# Add parent to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from config import config
from .function_declarations import FUNCTION_DECLARATIONS, SYSTEM_PROMPT

# Try to import Gemini
try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False
    print("⚠️  google-generativeai not installed. Install with: pip install google-generativeai")


def _proto_to_dict(obj):
    """
    Recursively convert Gemini proto objects to Python dicts/lists

    Handles:
    - MapComposite → dict
    - RepeatedComposite → list
    - Nested objects → recursive conversion
    """
    if hasattr(obj, 'items'):
        # It's a MapComposite (proto dict)
        return {key: _proto_to_dict(value) for key, value in obj.items()}
    elif hasattr(obj, '__iter__') and not isinstance(obj, (str, bytes)):
        # It's a RepeatedComposite (proto list) or regular iterable
        try:
            return [_proto_to_dict(item) for item in obj]
        except TypeError:
            return obj
    else:
        # It's a primitive (int, float, string, bool)
        return obj


class NaturalLanguageInterface:
    """
    Natural language interface using Gemini's native function calling

    Architecture:
    - User query → Gemini function calling → Structured parameters
    - No JSON parsing, no fallback parser needed
    - Type-safe parameters guaranteed by Gemini

    Examples:
        "Get TCS stock price" → query_stocks(filters={'ticker': 'TCS'})
        "Top 10 IT stocks" → query_stocks(filters={'sector': 'IT'}, limit=10, sort_by='market_cap')
        "TCS RSI" → calculate_indicators(ticker='TCS', indicators=['RSI'])
    """

    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize natural language interface with function calling

        Args:
            api_key: Gemini API key (defaults to config)
        """
        if not GEMINI_AVAILABLE:
            raise ImportError("google-generativeai not installed. Run: pip install google-generativeai")

        self.api_key = api_key or config.GEMINI_API_KEY

        # Configure Gemini
        genai.configure(api_key=self.api_key)

        # Initialize model with function calling
        # NOTE: Using gemini-2.0-flash-exp (supports function calling)
        self.model = genai.GenerativeModel(
            model_name='gemini-2.0-flash-exp',
            tools=[{'function_declarations': FUNCTION_DECLARATIONS}],
            system_instruction=SYSTEM_PROMPT
        )

        # Start chat session (for context preservation across queries)
        self.chat = self.model.start_chat()

    def parse_query(self, natural_language: str) -> Dict[str, Any]:
        """
        Convert natural language to function call using native function calling

        NO JSON PARSING - Gemini returns structured function calls directly

        Args:
            natural_language: User's question in plain English

        Returns:
            Dictionary with function_name and parameters

        Example:
            >>> parse_query("Get TCS stock price")
            {"function_name": "query_stocks", "params": {"filters": {"ticker": "TCS"}}}

            >>> parse_query("Top 10 IT stocks by market cap")
            {"function_name": "query_stocks",
             "params": {"filters": {"sector": "IT"}, "limit": 10, "sort_by": "market_cap"}}
        """
        try:
            # Send message to Gemini (function calling enabled)
            response = self.chat.send_message(natural_language)

            # Check if response has candidates
            if not response.candidates:
                return {
                    "error": "No response from LLM",
                    "original_query": natural_language
                }

            candidate = response.candidates[0]

            # Check if function call exists in response
            if not candidate.content.parts:
                return {
                    "error": "No content in LLM response",
                    "original_query": natural_language
                }

            part = candidate.content.parts[0]

            # Extract function call (structured output - NO PARSING!)
            if hasattr(part, 'function_call'):
                function_call = part.function_call

                # Convert function call to dictionary (recursively convert proto objects)
                return {
                    "function_name": function_call.name,
                    "params": _proto_to_dict(function_call.args)  # Recursively convert proto to Python dict
                }
            else:
                # LLM returned text instead of function call
                # This shouldn't happen with proper function declarations
                return {
                    "error": "LLM returned text instead of function call",
                    "text": part.text if hasattr(part, 'text') else str(part),
                    "original_query": natural_language
                }

        except Exception as e:
            return {
                "error": f"Function calling failed: {str(e)}",
                "original_query": natural_language,
                "exception_type": type(e).__name__
            }

    def query(self, natural_language: str, fetcher) -> Dict[str, Any]:
        """
        Complete flow: Parse natural language → Execute function → Return result

        Args:
            natural_language: User's question
            fetcher: UniversalDataFetcher instance

        Returns:
            Query result with data and metadata

        Example:
            >>> interface = NaturalLanguageInterface()
            >>> result = interface.query("What is TCS price?", fetcher)
            >>> print(result['data'])
        """
        # Parse natural language to function call (NO JSON PARSING!)
        parsed = self.parse_query(natural_language)

        # Check for errors
        if 'error' in parsed:
            return {
                'error': parsed['error'],
                'original_query': natural_language,
                'details': parsed
            }

        # Extract function name and parameters
        function_name = parsed['function_name']
        params = parsed['params']

        # Convert float to int for integer parameters (Gemini sometimes returns floats)
        if 'limit' in params and isinstance(params['limit'], float):
            params['limit'] = int(params['limit'])
        if 'days' in params and isinstance(params['days'], float):
            params['days'] = int(params['days'])

        # Execute appropriate function
        try:
            if function_name == 'query_stocks':
                result = fetcher.query_stocks(**params)
            elif function_name == 'calculate_indicators':
                result = fetcher.calculate_indicators(**params)
            elif function_name == 'query_corporate_actions':
                result = fetcher.query_corporate_actions(**params)
            elif function_name == 'fetch_stock_data':
                result = fetcher.fetch_stock_data(**params)
            else:
                return {
                    'error': f'Unknown function: {function_name}',
                    'original_query': natural_language,
                    'available_functions': ['query_stocks', 'calculate_indicators',
                                           'query_corporate_actions', 'fetch_stock_data']
                }

            # Add metadata about the query
            if result and isinstance(result, dict):
                if 'metadata' not in result:
                    result['metadata'] = {}
                result['metadata']['natural_language_query'] = natural_language
                result['metadata']['function_called'] = function_name
                result['metadata']['params_used'] = params

            return result

        except TypeError as e:
            # Parameter mismatch - fetcher method signature doesn't match
            return {
                'error': f'Parameter mismatch calling {function_name}: {str(e)}',
                'original_query': natural_language,
                'function_name': function_name,
                'params': params
            }
        except Exception as e:
            # Other execution errors
            return {
                'error': f'Execution failed: {str(e)}',
                'original_query': natural_language,
                'function_name': function_name,
                'params': params,
                'exception_type': type(e).__name__
            }


# Simple function interface (for backward compatibility)
def ask(question: str, fetcher) -> Dict[str, Any]:
    """
    Simple function to ask questions in natural language

    Args:
        question: Natural language question
        fetcher: UniversalDataFetcher instance

    Returns:
        Query result

    Example:
        >>> result = ask("Get TCS stock price", fetcher)
        >>> print(result['data'])
    """
    interface = NaturalLanguageInterface()
    return interface.query(question, fetcher)
